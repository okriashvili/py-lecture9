print("python 9th lecture: functions additional methonds: 'packing' and 'unpackings'")# packing / შეფუთვა: არგუმენტების შეფუთვა გამოიყენება *args - args არ არის საკვანძო სიტყვა,# მაგრამ მიზანშეწონილია რომ ეს სახელი დავარქვათ კონტეინერს# არგუმენტების შეფუთვა გულისხმობს მრავალი არგუმენტის გადაცემას ერთ კონტეინრში, ცალ ცალკე რომ არ გავუწეროთ ხელით# ვქმნით ერთ კონტეინერს, რომელსაც ვქმნით *ფიფქი და ამ კონეტეინერის სახელი(მიზანშეწონილია რომ ამ კონტეინერს დავაქრვათ args სახელად)def add(*args):    return argsprint(add(1, 2, 3, 4))#argsში გადაცემულ ამ ინფორმაციას, იგი გვიბრუნებს ტაპლის სახით, ტაპლის მონაცემის ტიპიაprint(type(add(1, 2, 3, 4)))# *args არის პარამეტრის სახელი# მსგავსად ტაპლისა თუკი ერთზე მეტ პარამეტრს გადაცვემთ - პარამეტრებს მონაცემები რიგითობის მიხედვით გადაეცემათdef sub(a, b, *args):    return a, b, argssub(1, 2, 3, 4, 5, 6, 7, 8)# მაგრამ განსხვავებით ტაპლისა, *args, ფიფქიანი პარამეტრი უნდა გადაცვეთ ბოლოში და არა თავში/შუაში# მონაცემებს იმ თანმიმდევრობით გამოიტანს, რა თანმიმდევრობითაც გადავცემთ returnში## def func(a, *args):#     return b, a, args## print(func(1, 2, 3, 4, 5, 6, 7, 8))# რა ადგილასაც გადავცემთ *იან პარამეტრს :# პარამეტრამდე არსებული პარამეტრები დაინაწილებენ რიგითობით მნიშვნელობებს,# * ფიფქიანი: იანი პარამეტრი მიიღებს დანარჩენ მნიშვნელობას# * ფიფქიან პარამეტრს შედგომ არსებული პარამაეტრები კი გამოიყენებელი დარჩება# კოდი ერორზე გავაdef my_func(a, *args):    return args, a, argsprint(my_func(1, 2, 3, 4, 5, 6, 7, 8))# რამდენჯერაც გამოვიძახებთ პარამეტრს returnით, იმდენჯერ დააბრუნებს მისთვის გადაცემულ მნიშვნელობასdef empty_func(*args):    return argsprint(empty_func())# პარამეტრისთვიის მნიშვნელობის გადაცემა არაა აუცილებელი, შეგვიძლია ცარიელი დავტოვოთ# def input_func(*args):#     return args# print(input_func(input("enter your name: ")))def x(a):    return "HELL0 WORLD"print(x(1))# unpacking!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# არგუმენტებს გახსნა ფუნქციაში:def f(a, b, c):    return a + b +clst = [1, 5, 6]print(f(*lst))# არგუმენტების გახსნა, ისევე მოქმედებს როგორც შფუთვა, მაგრამ განსხვაებით შეფუთვის, *ფიფქს ვუწერთ არა ფუქნციის პარამეტრებს, არამედ გამოძახებისას გადავცემთ *ფიფქს# ლისტში შეტანილი ელემენტები გაუტოლა= არგუმენტებს, რიგითობის მიხედვით / მაგრამ ლისტში ელემენტების რაოდენობა უნდა ემთხვეოდეს არგუმენტების რაოდენობას# ფუნქციას ვხსნით, გამოძახებისას გადაცემული *ფიფქის მიხედვით - რომელსაც ვუწერთ ლისტის ცვლადს# defauld parameter = დეფაულტ პარამეტრები :!!!!!!!!!!!!!!!!!!!!!!!!11# ფუქნციის განსაზღვრირსას,შეგვიძლია უშუალოდ პარამეტრებს გადავცეთ მშნიშვნელობა ,# თუკი, გამოძახების დროს ფუქნციის პარამეტრებს არ გადაეცა მნიშვნელობა მაშინ გამოიყენებს დეფაულტ პარამეტრს მნიშვნელობადdef func(name, lastname="okriashvili"):    return lastname, nameprint(func("malkhaz"))# უშუალოდ ფუქნციის შექმნინსას გადავცემთ პარამეტრს არგუმენტს# თუ გამოძახებისას არ გადაეცა მნიშვნელობა მას გამოიყენებს# დასახელებული არგუმენტები# უმენტები / keyword არგუმენტები:!!!!!!!!!!!!!!!!!# არგუმენტები რომლებიც პარამეტრებს უშუალოდ გამოძახებისას გადაეცემა, კონკრეტულ პარამტერსdef add(a, b):    return a + bprint(add(1, b=2))# პოვიზიურად კი არ გადავცემთ არგუმენტებს, არამედ უშუალოდ პარამეტრებს გადავცემთ# სამი სახის არგუმენეტბი გვაქვს:# 1: default- ანუ,ნაგულისხმევი პარამეტრი, რომელიც ყველაზე სუსტია# თუკი არც პოზიციური და არც დასახელებული არგუმეტი არ გვაქვს გამოიყენებს ნაგულისხმევ არგუმენტს# 2: პოზიციური არგუმენტი რომელსაც პიზიციურად გადავცემთ პარამეტრებს მათი რიგითობის მიხედვით# 3:დასახელებული არგუმენტი - უშუალოდ გამოძახებისას გადავცემთ უშუალოდ კონკრეტულ პარამეტრს, რომელიც ყველაზე ძლიერია და მას მიიღებს არგუმენტად# def sub(x, y):#     return x - y# print(sub(1, x=2))# რადგანაც პოზიციურად x არის პირველი, მას პოზიციურადავ მიიღებს პარამეტრი, და აგრეთვე მიიღებს დასახელებულ პარამეტრს## def person(name, surname, age):#     return f"{name}, {surname}, {age}"# print(person("malkhaz", 25, surname="me"))# ეს ფუნქციაც გავა ერორზე რადგანაც, surname-ს პოზიციურად გადაეცემა 25 იც და დასახელებული არგუმენტიც# def person(name, surname, age):#     return f"{name}, {surname}, {age}"# print(person("malkhaz", surname="me", 25))# პოზიციურად age-ს  კი გავუწერეთ 25 მაგრამ, დასახელებული არგიმენტის სინტაქსია რომ ის აუცილებლად ბოლოში უნდა იყოს გაწერილი# def person(name, surname="okriashvili",age):#     return f"{name}, {surname}, {age}"# print(person("malkhaz", age=25))# მსგავსად ეს ფუქნციაც გავა ერორზე, რადგანაც ნაგულისხმვი პარამეტრიც უნდა იუყოს დასმილუ ბოლოში# ნაგულისხემვიც და დასახელებული პარამეტრებიც უნდა დაიწეროს ბოლოში# kwargs da args!!!!!!!!!!!!!!!!!!!!!!!!# args გამოიყენება პოზიციური არგუმენტების შესაფუთად ხოლო# kwargs არის დასახელებული არგუმენტების შეფუთვაdef kwa(**kwargs):    return kwargsprint(kwa(name="malkhaz", surname="okriashvili", age=22))# kwargs ი გვიბრუნებს  დიქტის სახით# key-პარამეტრი / value-არგუმენტი# გამოძახებისას მათთვის **/* ფიფქის/ფიფქების გაწერა არაა საჭიროdef mix(*args, **kwargs):    return args, kwargsprint(mix(1, 2, 3, name="malkhaz", surname="okriashvili"))# შგვიძლია ავურიოთ და ერთად გადავცეთ ისინი# დასახელებულ არგუმენტებს მიიღებს kwargs# ხოლო პოზიციურ მიიღებს არგს# რიგითობუთაც ჯერნუნდა იყოს args და მერე უნდა დავწეროთ kwargs# LEGB: ფუნქციაში ფუნქცია და ა შ...:# L = Local# E - Enclosing# G - Global# B - Built-in# def main()# მნიშნვნელობებზე წვდომის ხერხის წესი თუ როგორ უნდა მივწვდეთ ცვლადებს ფუნქციიდან მაგ:x = "global"def external():    x = "enclosing"    def internal():        x = "local"# წვდომა განახორეიბელა xის local მნიშვნელობაზე, რადგანაც print ფუნქცია ჩადგმული გვაქსვს internal() ფუნქციაში# LEGB- წესი, მიყვება იმ ლოგიკას რომ იმ ფუნქციაში ჩადგმულ ცვადს გამოიძახებს სადაც რომელი ფუნქციაშიც ვიძახებთ მნიშვნელობას        print(x)    internal()external()x = "global"def external():    x = "enclosing"    def internal():        # x = "local"# მაგრამ, თუ ამ ფუნქციაში არ დახვდება მნიშვნელობა, ამშინ გავა ერთით გარეთ და იქ არსებულ ცვლადს გამოიძახებს# შიდნიდან გამიძახებით შეგივძლია მივწევდეთ გარეთ არსებულ ცვლადებს მაგრამ:!!!!!!!!!!!!        print(x)    internal()external()# მაგრამ გარედან შიგნით ვერ მივწვდებითdef access():    x = "internal"    return xprint(x)# access() შიგნით არსებულ x ცვლადს ვერ მივწდებით  ,# შიგნიდან > გარეთ არსებულ ცვლადზე შეგვიძია წვდომა მაგრამ,!!!!# გარედან > შიგნით არსებულ ცვლადზე წვდომას ვერ განვახორციელებთ