print("python 9th lecture: functions additional methonds: 'packing' and 'unpackings'")# packing / შეფუთვა: არგუმენტების შეფუთვა გამოიყენება *args - args არ არის საკვანძო სიტყვა,# მაგრამ მიზანშეწონილია რომ ეს სახელი დავარქვათ კონტეინერს# არგუმენტების შეფუთვა გულისხმობს მრავალი არგუმენტის გადაცემას ერთ კონტეინრში, ცალ ცალკე რომ არ გავუწეროთ ხელით# ვქმნით ერთ კონტეინერს, რომელსაც ვქმნით *ფიფქი და ამ კონეტეინერის სახელი(მიზანშეწონილია რომ ამ კონტეინერს დავაქრვათ args სახელად)def add(*args):    return argsprint(add(1, 2, 3, 4))#argsში გადაცემულ ამ ინფორმაციას, იგი გვიბრუნებს ტაპლის სახით, ტაპლის მონაცემის ტიპიაprint(type(add(1, 2, 3, 4)))# *args არის პარამეტრის სახელი# მსგავსად ტაპლისა თუკი ერთზე მეტ პარამეტრს გადაცვემთ - პარამეტრებს მონაცემები რიგითობის მიხედვით გადაეცემათdef sub(a, b, *args):    return a, b, argssub(1, 2, 3, 4, 5, 6, 7, 8)# მაგრამ განსხვავებით ტაპლისა, *args, ფიფქიანი პარამეტრი უნდა გადაცვეთ ბოლოში და არა თავში/შუაში# მონაცემებს იმ თანმიმდევრობით გამოიტანს, რა თანმიმდევრობითაც გადავცემთ returnში## def func(a, *args):#     return b, a, args## print(func(1, 2, 3, 4, 5, 6, 7, 8))# რა ადგილასაც გადავცემთ *იან პარამეტრს :# პარამეტრამდე არსებული პარამეტრები დაინაწილებენ რიგითობით მნიშვნელობებს,# * ფიფქიანი: იანი პარამეტრი მიიღებს დანარჩენ მნიშვნელობას# * ფიფქიან პარამეტრს შედგომ არსებული პარამაეტრები კი გამოიყენებელი დარჩება# კოდი ერორზე გავაdef my_func(a, *args):    return args, a, argsprint(my_func(1, 2, 3, 4, 5, 6, 7, 8))# რამდენჯერაც გამოვიძახებთ პარამეტრს returnით, იმდენჯერ დააბრუნებს მისთვის გადაცემულ მნიშვნელობასdef empty_func(*args):    return argsprint(empty_func())# პარამეტრისთვიის მნიშვნელობის გადაცემა არაა აუცილებელი, შეგვიძლია ცარიელი დავტოვოთ# def input_func(*args):#     return args# print(input_func(input("enter your name: ")))def x(a):    return "HELL0 WORLD"print(x(1))# unpacking!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!# არგუმენტებს გახსნა ფუნქციაში:def f(a, b, c):    return a + b +clst = [1, 5, 6]print(f(*lst))# არგუმენტების გახსნა, ისევე მოქმედებს როგორც შფუთვა, მაგრამ განსხვაებით შეფუთვის, *ფიფქს ვუწერთ არა ფუქნციის პარამეტრებს, არამედ გამოძახებისას გადავცემთ *ფიფქს# ლისტში შეტანილი ელემენტები გაუტოლა= არგუმენტებს, რიგითობის მიხედვით / მაგრამ ლისტში ელემენტების რაოდენობა უნდა ემთხვეოდეს არგუმენტების რაოდენობას# ფუნქციას ვხსნით, გამოძახებისას გადაცემული *ფიფქის მიხედვით - რომელსაც ვუწერთ ლისტის ცვლადს# defauld parameter = დეფაულტ პარამეტრები :!!!!!!!!!!!!!!!!!!!!!!!!11# ფუქნციის განსაზღვრირსას,შეგვიძლია უშუალოდ პარამეტრებს გადავცეთ მშნიშვნელობა ,# თუკი, გამოძახების დროს ფუქნციის პარამეტრებს არ გადაეცა მნიშვნელობა მაშინ გამოიყენებს დეფაულტ პარამეტრს მნიშვნელობადdef func(name, lastname="okriashvili"):    return lastname, nameprint(func("malkhaz"))# უშუალოდ ფუქნციის შექმნინსას გადავცემთ პარამეტრს არგუმენტს# თუ გამოძახებისას არ გადაეცა მნიშვნელობა მას გამოიყენებს# დასახელებული არგი# უმენტები / keyword არგუმენტები:!!!!!!!!!!!!!!!!!# არგუმენტები რომლებიც პარამეტრებს უშუალოდ გამოძახებისას გადაეცემა, კონკრეტულ პარამტერსdef add(a, b):    return a + bprint(add(1, b=2))# პოვიზიურად კი არ გადავცემთ არგუმენტებს, არამედ უშუალოდ პარამეტრებს გადავცემთ# სამი სახის არგუმენეტბი გვაქვს:# 1: default- ანუ,ნაგულისხმევი პარამეტრი, რომელიც ყველაზე სუსტია# თუკი არც პოზიციური და არც დასახელებული არგუმეტი არ გვაქვს გამოიყენებს ნაგულისხმევ არგუმენტს# 2: პოზიციური არგუმენტი რომელსაც პიზიციურად გადავცემთ პარამეტრებს მათი რიგითობის მიხედვით# 3:დასახელებული არგუმენტი - უშუალოდ გამოძახებისას გადავცემთ უშუალოდ კონკრეტულ პარამეტრს, რომელიც ყველაზე ძლიერია და მას მიიღებს არგუმენტად# def sub(x, y):#     return x - y# print(sub(1, x=2))# რადგანაც პოზიციურად x არის პირველი, მას პოზიციურადავ მიიღებს პარამეტრი, და აგრეთვე მიიღებს დასახელებულ პარამეტრს## def person(name, surname, age):#     return f"{name}, {surname}, {age}"# print(person("malkhaz", 25, surname="me"))# ეს ფუნქციაც გავა ერორზე რადგანაც, surname-ს პოზიციურად გადაეცემა 25 იც და დასახელებული არგუმენტიცimport random# print(random.choice(name))